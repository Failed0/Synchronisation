# Synchronisation
Question 1 In this exercise you will modify the zoo gate counter that you wrote last week and make it threadsafe.  Change your counter class so that no two Gates can increase the Counter at the same time (HINT: you may use the Counter's monitor).  Use the test class SynchronisationQ1Test.java to test your code.  Question 2 In this exercise you will extend the "number factory" from last week.  Last week you wrote a CyclicQueue as well as Producer and Consumer runnables. Since many Producers and Consumers will access the queue, we want to achieve three aims:  Synchronise the access such that no two threads interfere with each other. Have threads waiting - in a non-busy way - if they cannot perform their task right now. To achieve this, create a class Belt which extends the class CyclicQueue. In Belt override the enqueue and dequeue methods to guarantee the above aims.  Two Producers should not be able to add numbers at the same time, and two Consumers should not be able to remove numbers at the same time (such behaviour could never be thread-safe). dequeue should block if the belt is empty and continue once the belt contains numbers. Similarly, enqueue should block if the belt is full and continue once the belt has space again. Use the test class SynchronisationQ2Test.java to test your code.  If during the test there is an "illegal reflective access operation" warning this was produced by the test class and you may safely ignore the messages.  Question 3 In this exercise you will extend an application by writing a resource allocation class to solve the dining philosophers problem.  In the dining philosophers problem there are five philosophers sitting around a round table. Each philosopher has a fork to the left and a fork to the right. However, every fork is also shared with the respective left or right neighbour at the table. For example, a philosopher's right-hand fork is his/her right-hand neighbour's left-hand fork. In order to eat, a philosopher has to pick up both of the forks beside him/her; one after the other. Then the philosopher can use them to eat and place both back onto the table.  In this exercise, most of the classes are already supplied and you have to write only a part of the application to prevent a deadlock from happening.  At the centre is the Table class (package uk.ac.soton.ecs.comp1206.labtestlibrary.threading.philosopher) for philosophers (threads) to sit at and eat. The class creates 5 Seats (package uk.ac.soton.ecs.comp1206.labtestlibrary.interfaces.threading) and 5 forks. In general, the forks would be a resource that has to be locked. However, for simplicity the forks are the locks themselves (ReentrantLocks) in this exercise.  The test class SynchronisationQ3Test.java creates 5 philosophers who will sit at the table and try to eat, or, in other words, 5 threads that will try to lock the forks.  Your task is to create two types of Seats to avoid the philosopher ending up in a deadlock. The application will interact with the seats in the following way. The table will create 4 seats of your first implementation of Seat and 1 seat of your second implementation of Seat. Afterwards, the table calls assignForks to allocate the forks to the seats (where the two parameters of this method correspond to the left and right forks of the given seat, respectively). During their run, the philosophers call askFork1 and askFork2 to pick up the forks (always in this order).  In more detail, create two classes which both implement Seat (package uk.ac.soton.ecs.comp1206.labtestlibrary.interfaces.threading). The names of the classes do not matter and no constructor is required. Implement assignForks to get the forks/locks. Afterwards, implement askFork1 and askFork2 to give one of the forks to the philosopher, i.e., lock the ReentrantLock (you do not need to unlock it). Finally, create a class called Factory (here the name is important) which implements the SeatFactory interface (package uk.ac.soton.ecs.comp1206.labtestlibrary.interfaces.threading). Your Factory has to implement getSeats to create a Tuple (package uk.ac.soton.ecs.comp1206.labtestlibrary.recursion) which contains the class objects of your two Seat classes. The first value of the tuple shall be the first type of seat (of which 4 are created) and the second value shall be the second type of seat (of which 1 is created). For example, if your Seat classes are SeatX and SeatY, you should return a tuple containing SeatX.class and SeatY.class.  Use the test class SynchronisationQ3Test.java to test your code.  If during the test there is an "illegal reflective access operation" warning this was produced by the test class and you may safely ignore the messages.
